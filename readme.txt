このプログラムは書きかけなので注意してください．
使い方みたいなのはtestuse.mとtestuse2.mを実行したら大体分かってもらえると嬉しいです．
主な使い方
robotdefine.m(ロボット定義集)->controldefine(動作範囲とか制限とか制御定義集）
->robo = omunirobot(parameter,Deltat,x0,u0)（オムニロボット「robo」召還）
で初期設定終わり
robo.u = newu;（roboの新しい入力，制御入力とか計算)
->robo = robo.shiftx;(roboをルンゲクッタで10回積分)
–>10回繰り返す–>plot_omunirobot(robo,limit);で考えてるフィールドにroboを描画
->気の済むまでシミュレーション繰り返して終わり
各種ログ
hoge.Xlog（状態変数のlog [m][m][rad][m/s][m/s][rad/s][A]...[A])
hoge.Ulog（入力電圧のlog[V]）
hoge.Flog (グリップ力のlog[多分N])
hoge.Tlog (時間のlog[sec])
になります．
testuse.mでは入力を事前にランプ入力(1個は円を描くもの，1個は直線に移動を2回するもの）を計算していれてます．
testuse2.mではLQRコントローラを計算してそれによる二自由度制御を簡単に事前計算して入力しています．
testuse2.mを改造すれば実マシンの制御もシミュレーションできるかと
グリップ力も（怪しいですが）取れるので制御系の見積もりにもどうぞ．
タイヤが滑らないという仮定を入れてるのでグリップ力は無限大出せます．
なんであんまりグリップ力を大きくすると実マシンの応答とかけ離れた応答になるので注意してください．

モデル化の仮定と運動方程式についてのドキュメントも未完成なのでお待ちください．
一応\ell個のオムニホイールを持ったオムニマシンを対象にしてます．
i番目のオムニホイールに流れる電流をi_i[A]，ワールド座標系を[x y \theta]^Tと取って([m][m][rad])，
q_1 = [x y \theta]^T，q_2 = [i_1 \cdots i_\ell]^Tと一般化座標を選び，
x = [q_1^T \dot{q}_1^T q_2^T]^T を状態変数ととって非線形状態方程式を解きます．
モーターの回路方程式も解くので，サンプリングタイムは1.0x10^-4[sec]にしています．（これでも粗いかも）さらに入力の更新頻度は1.0x10^-3[sec]にしてあり，その時間まで問答無用で10回積分します．（何回積分するかは事前に設定したサンプリングタイムから計算してます）
そのため，10秒のシミュレーションでも結構かかるので注意が必要です．
また，挙動見てるとグリップ力F_iがなんか怪しいのでそこも注意してください．
また，実ロボットの諸元が不明だったのでノリでパラメータ選んでます．（モーターだけはmaxonから調べてます）
なので実マシンの応答が取りたいときは実マシンのパラメータを使ってください．（モーターもRE35じゃないなら変更を）
変えなきゃいけないのは
・I_0(オムニホイールとモーター等を抜いたマシンのz軸慣性モーメント)
・m_0(オムニホイールとモーター等を抜いたマシン質量)
・m_m(オムニホイールとモーター等からできる駆動ユニットあたりの質虜を含んだパラメータベクトル)
・r_m(オムニホイール中心からマシン中心までの距離を含んだパラメータベクトル）
・Gc(各モーターユニットの出力段までの減速比）
・Rc，Lc，JAc，KTc/KEc（各モーターの回路定数，内部抵抗，リアクタンス，ロータイナーシャ，トルクor回転定数）
・Dc，Jc（オムニホイールの直径，タイヤイナーシャ）
だと思います．（m_0とm_mは総和したらマシン総重量になる様に合わせてくれれば大丈夫じゃないかと思います）
重心位置を設定するパラメータ等もありますが，影響が小さいっぽいですし，同定が難しいので0で大丈夫かと．
